package com.codingame.gameengine.runner;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/***
 * Parse an HTML file and remove blocks between <code>&lt;!-- BEGIN keyword1 keyword2 --&gt;</code> and <code>&lt;!-- END --&gt;</code> Must contain a
 * block <code>&lt;!-- LEAGUES level1 level2 level3 level4 --&gt;</code><br>
 * <br>
 * The HTML file(s) must be named "statement_&lt;language&gt;.html.tpl" and placed in "config" directory
 */

public class StatementSplitter {

    private static final Pattern LEVEL = Pattern.compile("level(?<league>\\d+)");
    private static final Pattern LEAGUE_MARKER = Pattern.compile("\\s*<!--\\s+LEAGUES\\s+(?<leagues>.+)\\s+-->\\s*");
    private static final Pattern BEGIN_MARKER = Pattern.compile("\\s*<!--\\s+BEGIN\\s+(?<leagues>.+)\\s+-->\\s*");
    private static final Pattern END_MARKER = Pattern.compile("\\s*<!--\\s+END\\s+-->\\s*");
    private static final Pattern BEGIN_ALERT_MARKER = Pattern.compile("\\s*<!--\\s+LEAGUE\\s+ALERT\\s+-->\\s*");
    private static final Pattern END_ALERT_MARKER = Pattern.compile("\\s*<!--\\s+END\\s+LEAGUE\\s+ALERT\\s+-->\\s*");

    public static void generateSplittedStatement(Path sourceFolderPath, File statementFile, ExportReport exportReport) {
        //Retrieve content from the file
        List<String> lines = getLines(statementFile);

        List<String> leagues = getLeagues(lines);

        if (leagues.isEmpty()) {
            exportReport.addItem(ReportItemType.WARNING, statementFile.getName() + ": Statement splitter did not find leagues.");
            return;
        }

        for (String league : leagues) {
            sourceFolderPath.resolve("config/" + league).toFile().mkdir();
            if (!sourceFolderPath.resolve("config/" + league).toFile().isDirectory()) {
                throw new RuntimeException("Unable to access or create config/" + league + " directory.");
            }

            writeStatement(sourceFolderPath, statementFile, lines, league, exportReport);
        }
    }

    private static void writeStatement(Path sourceFolderPath, File statementFile, List<String> lines, String league, ExportReport exportReport) {
        Writer writer = null;
        try {
            //Substring to remove ".tpl" from the new file
            String newStatementFilename = statementFile.getName().substring(0, statementFile.getName().length() - 4);
            File newFile = sourceFolderPath.resolve("config/" + league + "/" + newStatementFilename).toFile();
            if (!newFile.exists()) {
                newFile.createNewFile();
            }

            writer = new BufferedWriter(
                new OutputStreamWriter(
                    new FileOutputStream(newFile)
                )
            );
            writer.write("<!-- Autogenerated file! Do not edit directly. -->");

            boolean visible = true;
            boolean inAlert = false;
            Stack<String> stack = new Stack<>();
            Stack<Boolean> highlight = new Stack<>();

            for (String line : lines) {
                Matcher beginMatcher = BEGIN_MARKER.matcher(line);
                if (BEGIN_ALERT_MARKER.matcher(line).matches()) {
                    inAlert = true;
                } else if (END_ALERT_MARKER.matcher(line).matches()) {
                    inAlert = false;
                } else if (beginMatcher.matches()) {
                    stack.push(beginMatcher.group("leagues"));
                    List<String> leagues = Arrays.asList(beginMatcher.group("leagues").split(" "));
                    visible = leagues.contains(league);
                    boolean alreadyHighlighted = highlight.isEmpty() ? false : highlight.peek();

                    highlight.push(alreadyHighlighted || visible && !inAlert && !leagues.contains(previousLeague(league)));

                    if (!alreadyHighlighted && highlight.peek()) {
                        writer.write(
                            "\n<div style=\"color: #7cc576;\n" +
                                "      background-color: rgba(124, 197, 118,.1);\n" +
                                "      padding: 2px; display:inline-block;\">\n"
                        );
                    }
                } else if (END_MARKER.matcher(line).matches()) {
                    if (stack.isEmpty()) {
                        exportReport.addItem(ReportItemType.WARNING, league + "/" + newStatementFilename + ": \"" + line + "\" unexpected");
                        writer.close();
                        return;
                    }
                    stack.pop();
                    if (stack.isEmpty()) {
                        visible = true;
                    } else {
                        List<String> leagues = Arrays.asList(stack.peek().split(" "));
                        visible = leagues.contains(league);
                    }
                    boolean highlighted = highlight.pop();
                    boolean previouslyHighlited = highlight.isEmpty() ? false : highlight.peek();

                    if (!previouslyHighlited && highlighted) {
                        writer.write(
                            "\n</div>\n"
                        );
                    }
                } else if (visible) {
                    writer.write(line);
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Cannot generate statement file.", e);
        } finally {
            try {
                writer.close();
            } catch (IOException e) {
                throw new RuntimeException("Cannot close statement file.", e);
            }
        }
    }

    private static String previousLeague(String league) {
        Matcher matcher = LEVEL.matcher(league);
        if (matcher.matches()) {
            int leagueNumber = Integer.parseInt(matcher.group("league"));
            if (leagueNumber > 1) {
                return "level" + (leagueNumber - 1);
            }
        }
        return league;
    }

    private static List<String> getLeagues(List<String> lines) {
        Matcher leagueMatcher;
        List<String> leagues = new ArrayList<>();
        for (String line : lines) {
            leagueMatcher = LEAGUE_MARKER.matcher(line);
            if (leagueMatcher.matches()) {
                leagues.addAll(Arrays.asList(leagueMatcher.group("leagues").split(" ")));
                break;
            }
        }
        return leagues;
    }

    private static List<String> getLines(File statementFile) {
        List<String> lines = new ArrayList<>();
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(statementFile));

            String statementContent = null;
            while ((statementContent = bufferedReader.readLine()) != null) {
                lines.add(statementContent + '\n');
            }
            bufferedReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return lines;
    }
}